// Code generated by goyacc -p semver -o parse_semver.y.go parse_semver.y. DO NOT EDIT.

//line parse_semver.y:2
package semver

import __yyfmt__ "fmt"

//line parse_semver.y:2

import (
	"errors"
	"fmt"
)

//line parse_semver.y:11
type semverSymType struct {
	yys     int
	ver     Semver
	pre     PreRelease
	pre_ids []PreReleaseID
	pre_id  PreReleaseID
	bld     Build
	bds     []BuildID
	bid     BuildID
	string  []byte
	char    byte
}

const SEMVER_HYPHEN = 57346
const SEMVER_LETTER = 57347
const SEMVER_ZERO = 57348
const SEMVER_POSITIVE_DIGIT = 57349

var semverToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"SEMVER_HYPHEN",
	"SEMVER_LETTER",
	"SEMVER_ZERO",
	"SEMVER_POSITIVE_DIGIT",
	"'.'",
	"'+'",
}
var semverStatenames = [...]string{}

const semverEofCode = 1
const semverErrCode = 2
const semverInitialStackSize = 16

//line parse_semver.y:160

type semverLexerImpl struct {
	pos int
	len int

	bytes []byte
	err   string

	result Semver
}

var lexm = map[lex]int{
	DOT:      int('.'),
	PLUS:     int('+'),
	HYPHEN:   SEMVER_HYPHEN,
	LETTER:   SEMVER_LETTER,
	POSITIVE: SEMVER_POSITIVE_DIGIT,
	ZERO:     SEMVER_ZERO,
}

func (s *semverLexerImpl) Lex(lval *semverSymType) int {
	if s.len <= s.pos {
		return 0
	}
	n := s.bytes[s.pos]
	s.pos++
	lval.char = n

	l, ok := lexMap[n]
	if !ok {
		s.err = fmt.Sprintf("invalid char at %d", s.pos-1)
		return int(n)
	}
	return lexm[l]
}

func (s *semverLexerImpl) Error(err string) {
	s.err = err
}

func Parse(s string) (Semver, error) {
	lex := &semverLexerImpl{bytes: []byte(s), len: len(s)}
	semverParse(lex)
	if lex.err != "" {
		return lex.result, errors.New(lex.err)
	}
	return lex.result, nil
}

//line yacctab:1
var semverExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 22,
	1, 28,
	8, 28,
	9, 28,
	-2, 33,
	-1, 23,
	4, 34,
	5, 34,
	-2, 29,
	-1, 33,
	4, 24,
	5, 24,
	-2, 31,
}

const semverPrivate = 57344

const semverLast = 62

var semverAct = [...]int{

	27, 32, 31, 20, 16, 29, 21, 25, 24, 34,
	35, 36, 7, 3, 28, 33, 18, 13, 42, 9,
	34, 35, 14, 12, 39, 40, 19, 38, 4, 5,
	39, 37, 10, 41, 44, 43, 6, 33, 25, 24,
	18, 26, 46, 33, 39, 44, 43, 47, 48, 11,
	19, 45, 25, 24, 22, 23, 8, 2, 30, 17,
	15, 1,
}
var semverPact = [...]int{

	22, -1000, 28, -1000, -1000, 22, 22, -1000, 24, -1000,
	22, 13, -1000, 48, 3, 2, -1000, 23, -1000, -1000,
	3, 34, -1000, 22, -1000, -1000, 3, -1000, -1000, -1000,
	10, -1000, -1000, 14, -1000, -1000, 3, 48, -1000, -1000,
	3, -1000, 3, -1000, 14, -1000, -1000, -1000, -1000,
}
var semverPgo = [...]int{

	0, 61, 60, 4, 59, 14, 5, 58, 2, 6,
	12, 57, 56, 49, 1, 41, 0, 3,
}
var semverR1 = [...]int{

	0, 1, 1, 1, 1, 11, 12, 13, 2, 3,
	3, 4, 4, 5, 6, 6, 7, 7, 8, 8,
	8, 8, 9, 9, 15, 15, 17, 17, 10, 10,
	10, 14, 14, 16, 16,
}
var semverR2 = [...]int{

	0, 5, 7, 7, 9, 1, 1, 1, 1, 1,
	3, 1, 1, 1, 1, 3, 1, 1, 1, 2,
	2, 3, 1, 2, 1, 1, 1, 1, 1, 1,
	2, 1, 2, 1, 1,
}
var semverChk = [...]int{

	-1000, -1, -11, -10, 6, 7, 8, -10, -12, -10,
	8, -13, -10, 4, 9, -2, -3, -4, -8, -10,
	-17, -9, 6, 7, 5, 4, -15, -16, -5, -6,
	-7, -8, -14, -16, 6, 7, 9, 8, -9, -17,
	-17, -9, 8, -14, -16, -5, -3, -9, -6,
}
var semverDef = [...]int{

	0, -2, 0, 5, 28, 29, 0, 30, 0, 6,
	0, 1, 7, 0, 0, 2, 8, 9, 11, 12,
	18, 0, -2, -2, 26, 27, 22, 24, 3, 13,
	14, 16, 17, -2, 33, 34, 0, 0, 19, 25,
	20, 23, 0, 32, 31, 4, 10, 21, 15,
}
var semverTok1 = [...]int{

	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 9, 3, 3, 8,
}
var semverTok2 = [...]int{

	2, 3, 4, 5, 6, 7,
}
var semverTok3 = [...]int{
	0,
}

var semverErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	semverDebug        = 0
	semverErrorVerbose = false
)

type semverLexer interface {
	Lex(lval *semverSymType) int
	Error(s string)
}

type semverParser interface {
	Parse(semverLexer) int
	Lookahead() int
}

type semverParserImpl struct {
	lval  semverSymType
	stack [semverInitialStackSize]semverSymType
	char  int
}

func (p *semverParserImpl) Lookahead() int {
	return p.char
}

func semverNewParser() semverParser {
	return &semverParserImpl{}
}

const semverFlag = -1000

func semverTokname(c int) string {
	if c >= 1 && c-1 < len(semverToknames) {
		if semverToknames[c-1] != "" {
			return semverToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func semverStatname(s int) string {
	if s >= 0 && s < len(semverStatenames) {
		if semverStatenames[s] != "" {
			return semverStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func semverErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !semverErrorVerbose {
		return "syntax error"
	}

	for _, e := range semverErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + semverTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := semverPact[state]
	for tok := TOKSTART; tok-1 < len(semverToknames); tok++ {
		if n := base + tok; n >= 0 && n < semverLast && semverChk[semverAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if semverDef[state] == -2 {
		i := 0
		for semverExca[i] != -1 || semverExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; semverExca[i] >= 0; i += 2 {
			tok := semverExca[i]
			if tok < TOKSTART || semverExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if semverExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += semverTokname(tok)
	}
	return res
}

func semverlex1(lex semverLexer, lval *semverSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = semverTok1[0]
		goto out
	}
	if char < len(semverTok1) {
		token = semverTok1[char]
		goto out
	}
	if char >= semverPrivate {
		if char < semverPrivate+len(semverTok2) {
			token = semverTok2[char-semverPrivate]
			goto out
		}
	}
	for i := 0; i < len(semverTok3); i += 2 {
		token = semverTok3[i+0]
		if token == char {
			token = semverTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = semverTok2[1] /* unknown char */
	}
	if semverDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", semverTokname(token), uint(char))
	}
	return char, token
}

func semverParse(semverlex semverLexer) int {
	return semverNewParser().Parse(semverlex)
}

func (semverrcvr *semverParserImpl) Parse(semverlex semverLexer) int {
	var semvern int
	var semverVAL semverSymType
	var semverDollar []semverSymType
	_ = semverDollar // silence set and not used
	semverS := semverrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	semverstate := 0
	semverrcvr.char = -1
	semvertoken := -1 // semverrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		semverstate = -1
		semverrcvr.char = -1
		semvertoken = -1
	}()
	semverp := -1
	goto semverstack

ret0:
	return 0

ret1:
	return 1

semverstack:
	/* put a state and value onto the stack */
	if semverDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", semverTokname(semvertoken), semverStatname(semverstate))
	}

	semverp++
	if semverp >= len(semverS) {
		nyys := make([]semverSymType, len(semverS)*2)
		copy(nyys, semverS)
		semverS = nyys
	}
	semverS[semverp] = semverVAL
	semverS[semverp].yys = semverstate

semvernewstate:
	semvern = semverPact[semverstate]
	if semvern <= semverFlag {
		goto semverdefault /* simple state */
	}
	if semverrcvr.char < 0 {
		semverrcvr.char, semvertoken = semverlex1(semverlex, &semverrcvr.lval)
	}
	semvern += semvertoken
	if semvern < 0 || semvern >= semverLast {
		goto semverdefault
	}
	semvern = semverAct[semvern]
	if semverChk[semvern] == semvertoken { /* valid shift */
		semverrcvr.char = -1
		semvertoken = -1
		semverVAL = semverrcvr.lval
		semverstate = semvern
		if Errflag > 0 {
			Errflag--
		}
		goto semverstack
	}

semverdefault:
	/* default state action */
	semvern = semverDef[semverstate]
	if semvern == -2 {
		if semverrcvr.char < 0 {
			semverrcvr.char, semvertoken = semverlex1(semverlex, &semverrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if semverExca[xi+0] == -1 && semverExca[xi+1] == semverstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			semvern = semverExca[xi+0]
			if semvern < 0 || semvern == semvertoken {
				break
			}
		}
		semvern = semverExca[xi+1]
		if semvern < 0 {
			goto ret0
		}
	}
	if semvern == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			semverlex.Error(semverErrorMessage(semverstate, semvertoken))
			Nerrs++
			if semverDebug >= 1 {
				__yyfmt__.Printf("%s", semverStatname(semverstate))
				__yyfmt__.Printf(" saw %s\n", semverTokname(semvertoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for semverp >= 0 {
				semvern = semverPact[semverS[semverp].yys] + semverErrCode
				if semvern >= 0 && semvern < semverLast {
					semverstate = semverAct[semvern] /* simulate a shift of "error" */
					if semverChk[semverstate] == semverErrCode {
						goto semverstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if semverDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", semverS[semverp].yys)
				}
				semverp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if semverDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", semverTokname(semvertoken))
			}
			if semvertoken == semverEofCode {
				goto ret1
			}
			semverrcvr.char = -1
			semvertoken = -1
			goto semvernewstate /* try again in the same state */
		}
	}

	/* reduction by production semvern */
	if semverDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", semvern, semverStatname(semverstate))
	}

	semvernt := semvern
	semverpt := semverp
	_ = semverpt // guard against "declared and not used"

	semverp -= semverR2[semvern]
	// semverp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if semverp+1 >= len(semverS) {
		nyys := make([]semverSymType, len(semverS)*2)
		copy(nyys, semverS)
		semverS = nyys
	}
	semverVAL = semverS[semverp+1]

	/* consult goto table to find next state */
	semvern = semverR1[semvern]
	semverg := semverPgo[semvern]
	semverj := semverg + semverS[semverp].yys + 1

	if semverj >= semverLast {
		semverstate = semverAct[semverg]
	} else {
		semverstate = semverAct[semverj]
		if semverChk[semverstate] != -semvern {
			semverstate = semverAct[semverg]
		}
	}
	// dummy call; replaced with literal code
	switch semvernt {

	case 1:
		semverDollar = semverS[semverpt-5 : semverpt+1]
//line parse_semver.y:44
		{
			semverlex.(*semverLexerImpl).result = Semver{Major: numbytes(semverDollar[1].string), Minor: numbytes(semverDollar[3].string), Patch: numbytes(semverDollar[5].string)}
		}
	case 2:
		semverDollar = semverS[semverpt-7 : semverpt+1]
//line parse_semver.y:48
		{
			semverlex.(*semverLexerImpl).result = Semver{Major: numbytes(semverDollar[1].string), Minor: numbytes(semverDollar[3].string), Patch: numbytes(semverDollar[5].string), PreRelease: semverDollar[7].pre}
		}
	case 3:
		semverDollar = semverS[semverpt-7 : semverpt+1]
//line parse_semver.y:52
		{
			semverlex.(*semverLexerImpl).result = Semver{Major: numbytes(semverDollar[1].string), Minor: numbytes(semverDollar[3].string), Patch: numbytes(semverDollar[5].string), Build: semverDollar[7].bld}
		}
	case 4:
		semverDollar = semverS[semverpt-9 : semverpt+1]
//line parse_semver.y:56
		{
			semverlex.(*semverLexerImpl).result = Semver{Major: numbytes(semverDollar[1].string), Minor: numbytes(semverDollar[3].string), Patch: numbytes(semverDollar[5].string), PreRelease: semverDollar[7].pre, Build: semverDollar[9].bld}
		}
	case 8:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:69
		{
			semverVAL.pre = PreRelease(semverDollar[1].pre_ids)
		}
	case 9:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:75
		{
			semverVAL.pre_ids = []PreReleaseID{semverDollar[1].pre_id}
		}
	case 10:
		semverDollar = semverS[semverpt-3 : semverpt+1]
//line parse_semver.y:79
		{
			semverVAL.pre_ids = append([]PreReleaseID{semverDollar[1].pre_id}, semverDollar[3].pre_ids...)
		}
	case 11:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:85
		{
			semverVAL.pre_id = PreReleaseID{str: string(semverDollar[1].string), isNum: false}
		}
	case 12:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:89
		{
			semverVAL.pre_id = PreReleaseID{str: string(semverDollar[1].string), num: numbytes(semverDollar[1].string), isNum: true}
		}
	case 13:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:95
		{
			semverVAL.bld = Build(semverDollar[1].bds)
		}
	case 14:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:100
		{
			semverVAL.bds = []BuildID{semverDollar[1].bid}
		}
	case 15:
		semverDollar = semverS[semverpt-3 : semverpt+1]
//line parse_semver.y:104
		{
			semverVAL.bds = append([]BuildID{semverDollar[1].bid}, semverDollar[3].bds...)
		}
	case 16:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:110
		{
			semverVAL.bid = BuildID(string(semverDollar[1].string))
		}
	case 17:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:114
		{
			semverVAL.bid = BuildID(string(semverDollar[1].string))
		}
	case 18:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:120
		{
			semverVAL.string = []byte{semverDollar[1].char}
		}
	case 19:
		semverDollar = semverS[semverpt-2 : semverpt+1]
//line parse_semver.y:122
		{
			semverVAL.string = append([]byte{semverDollar[1].char}, semverDollar[2].string...)
		}
	case 20:
		semverDollar = semverS[semverpt-2 : semverpt+1]
//line parse_semver.y:124
		{
			semverVAL.string = append(semverDollar[1].string, semverDollar[2].char)
		}
	case 21:
		semverDollar = semverS[semverpt-3 : semverpt+1]
//line parse_semver.y:126
		{
			semverVAL.string = append(append(semverDollar[1].string, semverDollar[2].char), semverDollar[3].string...)
		}
	case 22:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:130
		{
			semverVAL.string = []byte{semverDollar[1].char}
		}
	case 23:
		semverDollar = semverS[semverpt-2 : semverpt+1]
//line parse_semver.y:132
		{
			semverVAL.string = append([]byte{semverDollar[1].char}, semverDollar[2].string...)
		}
	case 28:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:144
		{
			semverVAL.string = []byte{semverDollar[1].char}
		}
	case 29:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:146
		{
			semverVAL.string = []byte{semverDollar[1].char}
		}
	case 30:
		semverDollar = semverS[semverpt-2 : semverpt+1]
//line parse_semver.y:148
		{
			semverVAL.string = append([]byte{semverDollar[1].char}, semverDollar[2].string...)
		}
	case 31:
		semverDollar = semverS[semverpt-1 : semverpt+1]
//line parse_semver.y:152
		{
			semverVAL.string = []byte{semverDollar[1].char}
		}
	case 32:
		semverDollar = semverS[semverpt-2 : semverpt+1]
//line parse_semver.y:154
		{
			semverVAL.string = append([]byte{semverDollar[1].char}, semverDollar[2].string...)
		}
	}
	goto semverstack /* stack new state and value */
}
