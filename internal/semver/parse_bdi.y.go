// Code generated by goyacc -p bdi -o parse_bdi.y.go parse_bdi.y. DO NOT EDIT.

//line parse_bdi.y:2
package semver

import __yyfmt__ "fmt"

//line parse_bdi.y:2

import "fmt"

//line parse_bdi.y:8
type bdiSymType struct {
	yys    int
	bid    BuildID
	string []byte
	char   byte
}

const BUILD_HYPHEN = 57346
const BUILD_LETTER = 57347
const BUILD_ZERO = 57348
const BUILD_POSITIVE_DIGIT = 57349

var bdiToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"BUILD_HYPHEN",
	"BUILD_LETTER",
	"BUILD_ZERO",
	"BUILD_POSITIVE_DIGIT",
}
var bdiStatenames = [...]string{}

const bdiEofCode = 1
const bdiErrCode = 2
const bdiInitialStackSize = 16

//line parse_bdi.y:79

type bdiLexerImpl struct {
	index        int
	len          int
	raw          []rune
	err          error
	syntaxErrPos int
	syntaxErr    string
	result       BuildID
}

func (s *bdiLexerImpl) Lex(lval *bdiSymType) int {
	if s.err != nil {
		return 0
	}
	if s.len <= s.index {
		return 0
	}
	n := s.raw[s.index]
	s.index++
	lval.char = byte(n)
	switch n {
	/* BUILD_HYPHEN: '-' */
	case '-':
		return BUILD_HYPHEN

	/* BUILD_ZERO: '0' */
	case '0':
		return BUILD_ZERO
	}

	/* BUILD_POSITIVE_DIGIT: '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' */
	if '1' <= n && n <= '9' {
		return BUILD_POSITIVE_DIGIT
	}

	/* BUILD_LETTER:
	  'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
	| 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
	| 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | 'a' | 'b' | 'c' | 'd'
	| 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
	| 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x'
	| 'y' | 'z' */
	if 'A' <= n && n <= 'Z' || 'a' <= n && n <= 'z' {
		return BUILD_LETTER
	}

	// TODO; check valid char
	if n == '.' || n == '+' {
		return int(n)
	}
	// other
	s.err = fmt.Errorf("invalid char at %d", s.index-1)
	return int(n)
}

func (s *bdiLexerImpl) Rune(r rune) int {
	return -1
}

func (s *bdiLexerImpl) Error(err string) {
	s.syntaxErrPos = s.index - 1
	s.syntaxErr = err
}

func MustParseBuildID(s string) BuildID {
	pre, err := ParseBuildID(s)
	if err != nil {
		panic(err)
	}
	return pre
}

func ParseBuildID(s string) (BuildID, error) {
	lex := &bdiLexerImpl{raw: []rune(s), len: len(s)}
	bdiParse(lex)
	if lex.err != nil {
		return lex.result, lex.err
	}
	if lex.syntaxErr != "" {
		return lex.result, fmt.Errorf("%s at %d", lex.syntaxErr, lex.syntaxErrPos)
	}
	return lex.result, nil
}

//line yacctab:1
var bdiExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 6,
	1, 16,
	-2, 9,
}

const bdiPrivate = 57344

const bdiLast = 24

var bdiAct = [...]int{

	13, 6, 9, 5, 10, 11, 2, 17, 12, 8,
	7, 10, 11, 18, 14, 4, 8, 7, 17, 19,
	15, 16, 3, 1,
}
var bdiPact = [...]int{

	5, -1000, -1000, -1000, 5, 12, -2, -1000, -1000, 5,
	-1000, -1000, -1000, -1000, -1000, 5, -1000, -2, -1000, -1000,
}
var bdiPgo = [...]int{

	0, 23, 6, 3, 6, 21, 2, 0, 14,
}
var bdiR1 = [...]int{

	0, 1, 1, 2, 2, 2, 2, 3, 3, 6,
	6, 8, 8, 4, 4, 4, 5, 5, 7, 7,
}
var bdiR2 = [...]int{

	0, 1, 1, 1, 2, 2, 3, 1, 2, 1,
	1, 1, 1, 1, 1, 2, 1, 2, 1, 1,
}
var bdiChk = [...]int{

	-1000, -1, -2, -5, -8, -3, -7, 5, 4, -6,
	6, 7, -3, -7, -8, -8, -5, -7, -3, -3,
}
var bdiDef = [...]int{

	0, -2, 1, 2, 3, 0, -2, 11, 12, 7,
	18, 19, 4, 9, 10, 5, 17, 16, 8, 6,
}
var bdiTok1 = [...]int{

	1,
}
var bdiTok2 = [...]int{

	2, 3, 4, 5, 6, 7,
}
var bdiTok3 = [...]int{
	0,
}

var bdiErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	bdiDebug        = 0
	bdiErrorVerbose = false
)

type bdiLexer interface {
	Lex(lval *bdiSymType) int
	Error(s string)
}

type bdiParser interface {
	Parse(bdiLexer) int
	Lookahead() int
}

type bdiParserImpl struct {
	lval  bdiSymType
	stack [bdiInitialStackSize]bdiSymType
	char  int
}

func (p *bdiParserImpl) Lookahead() int {
	return p.char
}

func bdiNewParser() bdiParser {
	return &bdiParserImpl{}
}

const bdiFlag = -1000

func bdiTokname(c int) string {
	if c >= 1 && c-1 < len(bdiToknames) {
		if bdiToknames[c-1] != "" {
			return bdiToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func bdiStatname(s int) string {
	if s >= 0 && s < len(bdiStatenames) {
		if bdiStatenames[s] != "" {
			return bdiStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func bdiErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !bdiErrorVerbose {
		return "syntax error"
	}

	for _, e := range bdiErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + bdiTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := bdiPact[state]
	for tok := TOKSTART; tok-1 < len(bdiToknames); tok++ {
		if n := base + tok; n >= 0 && n < bdiLast && bdiChk[bdiAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if bdiDef[state] == -2 {
		i := 0
		for bdiExca[i] != -1 || bdiExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; bdiExca[i] >= 0; i += 2 {
			tok := bdiExca[i]
			if tok < TOKSTART || bdiExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if bdiExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += bdiTokname(tok)
	}
	return res
}

func bdilex1(lex bdiLexer, lval *bdiSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = bdiTok1[0]
		goto out
	}
	if char < len(bdiTok1) {
		token = bdiTok1[char]
		goto out
	}
	if char >= bdiPrivate {
		if char < bdiPrivate+len(bdiTok2) {
			token = bdiTok2[char-bdiPrivate]
			goto out
		}
	}
	for i := 0; i < len(bdiTok3); i += 2 {
		token = bdiTok3[i+0]
		if token == char {
			token = bdiTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = bdiTok2[1] /* unknown char */
	}
	if bdiDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", bdiTokname(token), uint(char))
	}
	return char, token
}

func bdiParse(bdilex bdiLexer) int {
	return bdiNewParser().Parse(bdilex)
}

func (bdircvr *bdiParserImpl) Parse(bdilex bdiLexer) int {
	var bdin int
	var bdiVAL bdiSymType
	var bdiDollar []bdiSymType
	_ = bdiDollar // silence set and not used
	bdiS := bdircvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	bdistate := 0
	bdircvr.char = -1
	bditoken := -1 // bdircvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		bdistate = -1
		bdircvr.char = -1
		bditoken = -1
	}()
	bdip := -1
	goto bdistack

ret0:
	return 0

ret1:
	return 1

bdistack:
	/* put a state and value onto the stack */
	if bdiDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", bdiTokname(bditoken), bdiStatname(bdistate))
	}

	bdip++
	if bdip >= len(bdiS) {
		nyys := make([]bdiSymType, len(bdiS)*2)
		copy(nyys, bdiS)
		bdiS = nyys
	}
	bdiS[bdip] = bdiVAL
	bdiS[bdip].yys = bdistate

bdinewstate:
	bdin = bdiPact[bdistate]
	if bdin <= bdiFlag {
		goto bdidefault /* simple state */
	}
	if bdircvr.char < 0 {
		bdircvr.char, bditoken = bdilex1(bdilex, &bdircvr.lval)
	}
	bdin += bditoken
	if bdin < 0 || bdin >= bdiLast {
		goto bdidefault
	}
	bdin = bdiAct[bdin]
	if bdiChk[bdin] == bditoken { /* valid shift */
		bdircvr.char = -1
		bditoken = -1
		bdiVAL = bdircvr.lval
		bdistate = bdin
		if Errflag > 0 {
			Errflag--
		}
		goto bdistack
	}

bdidefault:
	/* default state action */
	bdin = bdiDef[bdistate]
	if bdin == -2 {
		if bdircvr.char < 0 {
			bdircvr.char, bditoken = bdilex1(bdilex, &bdircvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if bdiExca[xi+0] == -1 && bdiExca[xi+1] == bdistate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			bdin = bdiExca[xi+0]
			if bdin < 0 || bdin == bditoken {
				break
			}
		}
		bdin = bdiExca[xi+1]
		if bdin < 0 {
			goto ret0
		}
	}
	if bdin == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			bdilex.Error(bdiErrorMessage(bdistate, bditoken))
			Nerrs++
			if bdiDebug >= 1 {
				__yyfmt__.Printf("%s", bdiStatname(bdistate))
				__yyfmt__.Printf(" saw %s\n", bdiTokname(bditoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for bdip >= 0 {
				bdin = bdiPact[bdiS[bdip].yys] + bdiErrCode
				if bdin >= 0 && bdin < bdiLast {
					bdistate = bdiAct[bdin] /* simulate a shift of "error" */
					if bdiChk[bdistate] == bdiErrCode {
						goto bdistack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if bdiDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", bdiS[bdip].yys)
				}
				bdip--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if bdiDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", bdiTokname(bditoken))
			}
			if bditoken == bdiEofCode {
				goto ret1
			}
			bdircvr.char = -1
			bditoken = -1
			goto bdinewstate /* try again in the same state */
		}
	}

	/* reduction by production bdin */
	if bdiDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", bdin, bdiStatname(bdistate))
	}

	bdint := bdin
	bdipt := bdip
	_ = bdipt // guard against "declared and not used"

	bdip -= bdiR2[bdin]
	// bdip is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if bdip+1 >= len(bdiS) {
		nyys := make([]bdiSymType, len(bdiS)*2)
		copy(nyys, bdiS)
		bdiS = nyys
	}
	bdiVAL = bdiS[bdip+1]

	/* consult goto table to find next state */
	bdin = bdiR1[bdin]
	bdig := bdiPgo[bdin]
	bdij := bdig + bdiS[bdip].yys + 1

	if bdij >= bdiLast {
		bdistate = bdiAct[bdig]
	} else {
		bdistate = bdiAct[bdij]
		if bdiChk[bdistate] != -bdin {
			bdistate = bdiAct[bdig]
		}
	}
	// dummy call; replaced with literal code
	switch bdint {

	case 1:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:29
		{
			bdilex.(*bdiLexerImpl).result = BuildID(string(bdiDollar[1].string))
		}
	case 2:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:33
		{
			bdilex.(*bdiLexerImpl).result = BuildID(string(bdiDollar[1].string))
		}
	case 3:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:39
		{
			bdiVAL.string = []byte{bdiDollar[1].char}
		}
	case 4:
		bdiDollar = bdiS[bdipt-2 : bdipt+1]
//line parse_bdi.y:41
		{
			bdiVAL.string = append([]byte{bdiDollar[1].char}, bdiDollar[2].string...)
		}
	case 5:
		bdiDollar = bdiS[bdipt-2 : bdipt+1]
//line parse_bdi.y:43
		{
			bdiVAL.string = append(bdiDollar[1].string, bdiDollar[2].char)
		}
	case 6:
		bdiDollar = bdiS[bdipt-3 : bdipt+1]
//line parse_bdi.y:45
		{
			bdiVAL.string = append(append(bdiDollar[1].string, bdiDollar[2].char), bdiDollar[3].string...)
		}
	case 7:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:49
		{
			bdiVAL.string = []byte{bdiDollar[1].char}
		}
	case 8:
		bdiDollar = bdiS[bdipt-2 : bdipt+1]
//line parse_bdi.y:51
		{
			bdiVAL.string = append([]byte{bdiDollar[1].char}, bdiDollar[2].string...)
		}
	case 13:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:63
		{
			bdiVAL.string = []byte{bdiDollar[1].char}
		}
	case 14:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:65
		{
			bdiVAL.string = []byte{bdiDollar[1].char}
		}
	case 15:
		bdiDollar = bdiS[bdipt-2 : bdipt+1]
//line parse_bdi.y:67
		{
			bdiVAL.string = append([]byte{bdiDollar[1].char}, bdiDollar[2].string...)
		}
	case 16:
		bdiDollar = bdiS[bdipt-1 : bdipt+1]
//line parse_bdi.y:71
		{
			bdiVAL.string = []byte{bdiDollar[1].char}
		}
	case 17:
		bdiDollar = bdiS[bdipt-2 : bdipt+1]
//line parse_bdi.y:73
		{
			bdiVAL.string = append([]byte{bdiDollar[1].char}, bdiDollar[2].string...)
		}
	}
	goto bdistack /* stack new state and value */
}
